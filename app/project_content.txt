----- File: ./admin/sortable-social-item.tsx -----
"use client";

import {CSS} from "@dnd-kit/utilities";
import {useSortable} from "@dnd-kit/sortable";
import {Switch} from "@/components/ui/switch";
import {Input} from "@/components/ui/input";
import {SocialLinkData} from "./types";
import {FaGithub, FaInstagram, FaLinkedin, FaTiktok, FaXTwitter, FaYoutube,} from "react-icons/fa6";

function getSocialIcon(name: string) {
    switch (name) {
        case "instagram":
            return <FaInstagram />;
        case "twitter":
            return <FaXTwitter />;
        case "youtube":
            return <FaYoutube />;
        case "tiktok":
            return <FaTiktok />;
        case "github":
            return <FaGithub />;
        case "linkedin":
            return <FaLinkedin />;
        default:
            return null;
    }
}

interface SortableSocialItemProps {
    social: SocialLinkData;
    onUpdate: (id: string, updates: Partial<SocialLinkData>) => void;
}

export function SortableSocialItem({social, onUpdate}: SortableSocialItemProps) {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging,
    } = useSortable({ id: social.id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        background: isDragging ? "rgba(255,255,255,0.1)" : "transparent",
    };

    const Icon = getSocialIcon(social.name);

    return (
        <li
            ref={setNodeRef}
            style={style}
            className="border p-2 rounded flex items-center justify-left gap-2 border-gray-500"
        >
            <div
                className="cursor-grab px-2 select-none text-sm bg-gray-700 text-white rounded w-fit"
                {...attributes}
                {...listeners}
            >
                ☰
            </div>
            <div className="flex items-center gap-2">
                {Icon && <span className="text-xl">{Icon}</span>}
                <select
                    className="border rounded p-1 border-gray-500"
                    value={social.name}
                    onChange={(e) => onUpdate(social.id, {name: e.target.value})}
                >
                    <option value="instagram">Instagram</option>
                    <option value="twitter">Twitter</option>
                    <option value="youtube">YouTube</option>
                    <option value="tiktok">TikTok</option>
                    <option value="github">GitHub</option>
                    <option value="linkedin">LinkedIn</option>
                </select>
            </div>
            <div className="flex-1 flex flex-col border-gray-500">
                <label className="text-sm font-medium text-gray-300">URL</label>
                <Input
                    className={"border-gray-500"}
                    value={social.url}
                    onChange={(e) => onUpdate(social.id, {url: e.target.value})}
                />
            </div>
            <div className="flex flex-col">
                <label className="text-sm font-medium">Visible</label>
                <Switch
                    className="data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-red-500"
                    checked={social.visible}
                    onCheckedChange={(checked) => onUpdate(social.id, {visible: checked})}
                />
            </div>
        </li>
    );
}



----- File: ./admin/social-links-panel.tsx -----
"use client";

import {useEffect, useState} from "react";
import {
    closestCenter,
    DndContext,
    DragEndEvent,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
} from "@dnd-kit/core";
import {arrayMove, SortableContext, verticalListSortingStrategy,} from "@dnd-kit/sortable";
import {SocialLinkData} from "./types";
import {SortableSocialItem} from "./sortable-social-item";

export default function SocialLinksPanel() {
    const [socialLinks, setSocialLinks] = useState<SocialLinkData[]>([]);

    useEffect(() => {
        fetch("/api/social-links")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) {
                    setSocialLinks(data);
                }
            })
            .catch((err) => console.error("Error fetching social links:", err));
    }, []);

    async function handleUpdate(id: string, updates: Partial<SocialLinkData>) {
        try {
            const res = await fetch("/api/social-links", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id, ...updates }),
            });
            const data = await res.json();
            if (res.ok) {
                setSocialLinks((prev) =>
                    prev.map((s) => (s.id === id ? { ...s, ...data } : s))
                );
            } else {
                console.error("Error updating social link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    }

    const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor));

    function handleDragEnd(event: DragEndEvent) {
        const { active, over } = event;
        if (!over || active.id === over.id) return;

        const oldIndex = socialLinks.findIndex((s) => s.id === active.id);
        const newIndex = socialLinks.findIndex((s) => s.id === over.id);
        if (oldIndex < 0 || newIndex < 0) return;

        const newArr = arrayMove(socialLinks, oldIndex, newIndex);
        const updated = newArr.map((s, idx) => ({ ...s, position: idx }));
        setSocialLinks(updated);

        fetch("/api/social-links", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(updated.map((item) => ({id: item.id, position: item.position}))),
        });
    }

    return (
        <div className="border p-4 my-8 border-purple-900">
            <h2 className="text-lg font-semibold">Social Links</h2>
            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext
                    items={socialLinks.map((s) => s.id)}
                    strategy={verticalListSortingStrategy}
                >
                    <ul className="space-y-2">
                        {socialLinks
                            .sort((a, b) => a.position - b.position)
                            .map((soc) => (
                                <SortableSocialItem key={soc.id} social={soc} onUpdate={handleUpdate}/>
                            ))}
                    </ul>
                </SortableContext>
            </DndContext>
        </div>
    );
}



----- File: ./admin/multi-sections-board.tsx -----
// MultiSectionsBoard.tsx (o donde quieras colocar el botón)
// Ajusta la ubicación exacta según tu preferencia

"use client";

import {useEffect, useState} from "react";
import {
    DndContext,
    DragEndEvent,
    DragOverEvent,
    DragOverlay,
    DragStartEvent,
    KeyboardSensor,
    PointerSensor,
    rectIntersection,
    useSensor,
    useSensors,
} from "@dnd-kit/core";
import {arrayMove, SortableContext, verticalListSortingStrategy} from "@dnd-kit/sortable";
import {LinkData, SectionData} from "./types";
import MultiSectionsContainer from "./multi-sections-container";

interface MultiSectionsBoardProps {
    links: LinkData[];
    setLinks: React.Dispatch<React.SetStateAction<LinkData[]>>;
    sections: SectionData[];
    setSections: React.Dispatch<React.SetStateAction<SectionData[]>>;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
    onDeleteLink: (id: string) => void;
    onUpdateSection: (id: string, updates: Partial<SectionData>) => void;
    onDeleteSection: (id: string) => void;
}

export default function MultiSectionsBoard({
                                               links,
                                               setLinks,
                                               sections,
                                               setSections,
                                               onUpdateLink,
                                               onDeleteLink,
                                               onUpdateSection,
                                               onDeleteSection,
                                           }: MultiSectionsBoardProps) {
    const [containers, setContainers] = useState<{ id: string; items: string[] }[]>([]);
    const [activeId, setActiveId] = useState<string | null>(null);
    const [showOverlay, setShowOverlay] = useState(false);

    useEffect(() => {
        const noSectionItems = links
            .filter((l) => l.section_id === null)
            .sort((a, b) => a.position - b.position)
            .map((l) => l.id);

        const sortedSecs = [...sections].sort((a, b) => a.position - b.position);

        const sectionContainers = sortedSecs.map((sec) => {
            const secItems = links
                .filter((l) => l.section_id === sec.id)
                .sort((a, b) => a.position - b.position)
                .map((l) => l.id);
            return { id: sec.id, items: secItems };
        });

        setContainers([{id: "no-section", items: noSectionItems}, ...sectionContainers]);
    }, [links, sections]);

    const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor));

    async function createLinkInSection(sectionId: string) {
        const container = containers.find((c) => c.id === sectionId);
        const newPos = container ? container.items.length : 0;

        const dummyLink = {
            title: "Nuevo Enlace",
            url: "",
            image: "",
            visible: true,
            position: newPos,
            section_id: sectionId === "no-section" ? null : sectionId,
        };
        try {
            const res = await fetch("/api/links", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(dummyLink),
            });
            const data = await res.json();
            if (res.ok) {
                setLinks((prev) => [...prev, data]);
            } else {
                console.error("Error creando link:", data.error);
            }
        } catch (error) {
            console.error("Error creando link:", error);
        }
    }

    function handleDragStart(event: DragStartEvent) {
        setActiveId(event.active.id as string);
        setShowOverlay(false);
    }

    function handleDragOver(event: DragOverEvent) {
        const {active, over} = event;
        if (!over) return;
        const activeContainer = containers.find((c) => c.items.includes(active.id as string));
        const overContainer =
            containers.find((c) => c.items.includes(over.id as string)) ||
            containers.find((c) => c.id === (over.id as string));

        if (!activeContainer || !overContainer) {
            setShowOverlay(false);
            return;
        }
        setShowOverlay(activeContainer.id !== overContainer.id);
    }

    function handleDragEnd(event: DragEndEvent) {
        const { active, over } = event;
        setActiveId(null);
        setShowOverlay(false);
        if (!over) return;

        const activeContainer = containers.find((c) => c.items.includes(active.id as string));
        const overContainer =
            containers.find((c) => c.items.includes(over.id as string)) ||
            containers.find((c) => c.id === (over.id as string));

        if (!activeContainer || !overContainer) return;
        if (activeContainer.id === overContainer.id && active.id === over.id) {
            return;
        }

        const newContainers = structuredClone(containers);
        const fromIndex = newContainers.findIndex((c) => c.id === activeContainer.id);
        const toIndex = newContainers.findIndex((c) => c.id === overContainer.id);

        const fromItems = newContainers[fromIndex].items;
        const toItems = newContainers[toIndex].items;

        const oldIndex = fromItems.indexOf(active.id as string);
        let newIndex = toItems.indexOf(over.id as string);
        if (newIndex === -1) {
            newIndex = toItems.length;
        }

        if (activeContainer.id === overContainer.id) {
            const reordered = arrayMove(fromItems, oldIndex, newIndex);
            newContainers[fromIndex].items = reordered;
            reorderLinksInContainer(reordered);
        } else {
            fromItems.splice(oldIndex, 1);
            toItems.splice(newIndex, 0, active.id as string);
            updateLinkContainer(active.id as string, overContainer.id);
            reorderLinksInContainer(toItems);
            reorderLinksInContainer(fromItems);
        }
        setContainers(newContainers);
    }

    async function updateLinkContainer(linkId: string, containerId: string) {
        const newSectionId = containerId === "no-section" ? null : containerId;
        setLinks((prev) => {
            const newLinks = structuredClone(prev);
            const link = newLinks.find((l) => l.id === linkId);
            if (link) {
                link.section_id = newSectionId;
            }
            return newLinks;
        });
        await fetch("/api/links", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({id: linkId, section_id: newSectionId}),
        });
    }

    async function reorderLinksInContainer(itemIds: string[]) {
        setLinks((prev) => {
            const newLinks = structuredClone(prev);
            itemIds.forEach((id, idx) => {
                const link = newLinks.find((l) => l.id === id);
                if (link) {
                    link.position = idx;
                }
            });
            return newLinks;
        });

        const updates = itemIds.map((id, idx) => ({ id, position: idx }));
        await fetch("/api/links", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(updates),
        });
    }

    function moveSectionUp(sectionId: string) {
        setSections((prev) => {
            const idx = prev.findIndex((s) => s.id === sectionId);
            if (idx <= 0) return prev;
            const newArr = [...prev];
            [newArr[idx], newArr[idx - 1]] = [newArr[idx - 1], newArr[idx]];
            newArr.forEach((sec, i) => {
                sec.position = i;
            });
            patchSections(newArr);
            return newArr;
        });
    }

    function moveSectionDown(sectionId: string) {
        setSections((prev) => {
            const idx = prev.findIndex((s) => s.id === sectionId);
            if (idx < 0 || idx >= prev.length - 1) return prev;
            const newArr = [...prev];
            [newArr[idx], newArr[idx + 1]] = [newArr[idx + 1], newArr[idx]];
            newArr.forEach((sec, i) => {
                sec.position = i;
            });
            patchSections(newArr);
            return newArr;
        });
    }

    async function patchSections(finalArr: SectionData[]) {
        const body = finalArr.map((sec) => ({
            id: sec.id,
            position: sec.position,
        }));
        await fetch("/api/sections", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
        });
    }

    async function createNewSection() {
        try {
            const dummySection = {title: "Sección Nueva", position: sections.length};
            const res = await fetch("/api/sections", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify(dummySection),
            });
            const data = await res.json();
            if (res.ok) {
                setSections((prev) => [...prev, data]);
            } else {
                console.error("Error creando sección:", data.error);
            }
        } catch (error) {
            console.error("Error creando sección:", error);
        }
    }

    const activeLink = activeId ? links.find((l) => l.id === activeId) : null;

    return (
        <DndContext
            sensors={sensors}
            collisionDetection={rectIntersection}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDragEnd={handleDragEnd}
        >
            <SortableContext
                items={containers.map((c) => c.id)}
                strategy={verticalListSortingStrategy}
            >
                <div className="flex flex-col gap-6">
                    {containers.map((container, idx) => (
                        <MultiSectionsContainer
                            key={container.id}
                            containerId={container.id}
                            items={container.items}
                            links={links}
                            sections={sections}
                            moveSectionUp={moveSectionUp}
                            moveSectionDown={moveSectionDown}
                            idx={idx}
                            total={containers.length}
                            onUpdateLink={onUpdateLink}
                            onDeleteLink={onDeleteLink}
                            onCreateLinkInSection={createLinkInSection}
                            onUpdateSection={onUpdateSection}
                            onDeleteSection={onDeleteSection}
                        />
                    ))}

                    {/* Botón centrado */}
                    <div className="flex justify-center mt-8">
                        <button
                            onClick={createNewSection}
                            className="border border-white bg-black text-white px-4 py-2 rounded flex flex-col items-center"
                        >
                            <svg
                                className="w-6 h-6"
                                fill="none"
                                stroke="currentColor"
                                strokeWidth={1.5}
                                viewBox="0 0 24 24"
                            >
                                <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15"/>
                            </svg>
                            <span className="mt-1 text-sm">Nueva Sección</span>
                        </button>
                    </div>
                </div>
            </SortableContext>

            <DragOverlay dropAnimation={null}>
                {showOverlay && activeLink ? <OverlayItem link={activeLink}/> : null}
            </DragOverlay>
        </DndContext>
    );
}

function OverlayItem({link}: { link: LinkData }) {
    return (
        <div className="cursor-grab text-sm text-gray-300 bg-gray-700 rounded px-2 p-2">
            <div className="font-semibold">{link.title}</div>
            <div className="text-xs text-gray-400">{link.url}</div>
        </div>
    );
}



----- File: ./admin/extract-text.sh -----
#!/bin/bash
# Este script recorre recursivamente el directorio actual y, para cada archivo de tipo texto,
# añade una cabecera con la ruta y nombre del archivo y su contenido en output/project_content.txt.
# Se excluye el directorio 'output' para evitar procesar el archivo de salida.

OUTPUT_DIR="./output"
OUTPUT_FILE="$OUTPUT_DIR/project_content.txt"

# Creamos el directorio de salida si no existe
mkdir -p "$OUTPUT_DIR"

# Limpiamos el archivo de salida si ya existe
> "$OUTPUT_FILE"

# Encuentra todos los archivos, excluyendo el directorio de salida para evitar procesarlo
find . -path "$OUTPUT_DIR" -prune -o -type f -print | while IFS= read -r file; do
    # Usamos 'file' para determinar el MIME type y comprobamos que empiece por "text/"
    mime=$(file -b --mime-type "$file")
    if [[ $mime == text/* ]]; then
        echo "----- File: $file -----" >> "$OUTPUT_FILE"
        cat "$file" >> "$OUTPUT_FILE"
        echo -e "\n\n" >> "$OUTPUT_FILE"
    fi
done

echo "Contenido extraído en: $OUTPUT_FILE"



----- File: ./admin/types.ts -----
// app/admin/types.ts

export interface SocialLinkData {
    id: string;
    name: string;
    url: string;
    visible: boolean;
    position: number;
}

export interface LinkData {
    id: string;
    title: string;
    url: string;
    image?: string;
    visible: boolean;
    position: number;
    section_id?: string | null;
}

export interface SectionData {
    id: string;
    title: string;
    position: number;
}



----- File: ./admin/multi-sections-item.tsx -----
"use client";

import {CSS} from "@dnd-kit/utilities";
import {useSortable} from "@dnd-kit/sortable";
import React, {useState} from "react";
import {Button} from "@/components/ui/button";
import {Input} from "@/components/ui/input";
import {Switch} from "@/components/ui/switch";
import {LinkData} from "./types";

function PencilIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className="size-6"
        >
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931ZM19.5 7.125 16.862 4.487"
            />
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"
            />
        </svg>
    );
}
function TrashIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className="size-6"
        >
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673A2.25 2.25 0 0 1 15.916 21H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397M4.75 5.75h14.5"
            />
        </svg>
    );
}

interface MultiSectionsItemProps {
    link: LinkData;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
    onDeleteLink: (id: string) => void;
}

export default function MultiSectionsItem({
                                              link,
                                              onUpdateLink,
                                              onDeleteLink,
                                          }: MultiSectionsItemProps) {
    const {
        setNodeRef,
        setActivatorNodeRef,
        attributes,
        listeners,
        transform,
        transition,
        isDragging,
    } = useSortable({id: link.id});

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        background: isDragging ? "rgba(255,255,255,0.1)" : "transparent",
    };

    const [isEditing, setIsEditing] = useState(false);
    const [showDeleteModal, setShowDeleteModal] = useState(false);

    const [editTitle, setEditTitle] = useState(link.title);
    const [editUrl, setEditUrl] = useState(link.url);
    const [editImage, setEditImage] = useState(link.image ?? "");

    function handleSave() {
        onUpdateLink(link.id, {
            title: editTitle,
            url: editUrl,
            image: editImage,
        });
        setIsEditing(false);
    }

    function handleCancel() {
        setIsEditing(false);
        setEditTitle(link.title);
        setEditUrl(link.url);
        setEditImage(link.image ?? "");
    }

    function toggleVisible(checked: boolean) {
        onUpdateLink(link.id, { visible: checked });
    }

    function handleDeleteClick() {
        setShowDeleteModal(true);
    }

    function confirmDelete() {
        setShowDeleteModal(false);
        onDeleteLink(link.id);
    }

    function cancelDelete() {
        setShowDeleteModal(false);
    }

    return (
        <li ref={setNodeRef} style={style} className="border p-3 rounded border-gray-500">
            {isEditing ? (
                <div className="flex flex-col gap-2">
                    <div className="flex items-center gap-2">
                        <label className="text-sm">Título:</label>
                        <Input value={editTitle} onChange={(e) => setEditTitle(e.target.value)}/>
                    </div>
                    <div className="flex items-center gap-2">
                        <label className="text-sm">URL:</label>
                        <Input value={editUrl} onChange={(e) => setEditUrl(e.target.value)}/>
                    </div>
                    <div className="flex items-center gap-2">
                        <label className="text-sm">Imagen:</label>
                        <Input value={editImage} onChange={(e) => setEditImage(e.target.value)}/>
                    </div>
                    <div className="flex gap-2 justify-end">
                        <Button variant="secondary" onClick={handleCancel}>
                            Cancelar
                        </Button>
                        <Button onClick={handleSave}>Guardar</Button>
                    </div>
                </div>
            ) : (
                <div className="flex items-center gap-4">
                    <div
                        className="cursor-grab px-2 select-none text-sm bg-gray-700 text-white rounded w-fit"
                        ref={setActivatorNodeRef}
                        {...attributes}
                        {...listeners}
                    >
                        ☰
                    </div>
                    {link.image && (
                        <img
                            src={link.image}
                            alt={link.title}
                            className="w-10 h-10 object-cover rounded"
                        />
                    )}
                    <div>
                        <div className="font-semibold">{link.title}</div>
                        <div className="text-xs text-gray-400">{link.url}</div>
                    </div>
                    <div className="flex-1" />
                    <div className="flex items-center gap-2">
                        <Switch
                            className="data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-red-500"
                            checked={link.visible}
                            onCheckedChange={toggleVisible}
                        />
                        <Button onClick={() => setIsEditing(true)}>
                            <PencilIcon/>
                        </Button>
                        <Button variant="destructive" onClick={handleDeleteClick}>
                            <TrashIcon/>
                        </Button>
                    </div>
                </div>
            )}

            {showDeleteModal && (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
                    <div className="bg-black w-full max-w-sm mx-auto p-4 rounded shadow-lg">
                        <p className="mb-4">¿Seguro que deseas borrar este enlace?</p>
                        <div className="flex justify-end gap-2">
                            <Button variant="secondary" onClick={cancelDelete}>
                                Cancelar
                            </Button>
                            <Button variant="destructive" onClick={confirmDelete}>
                                Borrar
                            </Button>
                        </div>
                    </div>
                </div>
            )}
        </li>
    );
}



----- File: ./admin/page.tsx -----
// app/admin/page.tsx

"use client";

import {useEffect, useState} from "react";
import {LinkData, SectionData} from "./types";
import MultiSectionsBoard from "./multi-sections-board";
import SocialLinksPanel from "./social-links-panel";
import LandingPreview from "../landing-content";

export default function AdminPage() {
    const [links, setLinks] = useState<LinkData[]>([]);
    const [sections, setSections] = useState<SectionData[]>([]);

    useEffect(() => {
        fetch("/api/links")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) setLinks(data);
            })
            .catch((err) => console.error(err));

        fetch("/api/sections")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) setSections(data);
            })
            .catch((err) => console.error(err));
    }, []);

    async function handleDeleteLink(id: string) {
        try {
            const res = await fetch(`/api/links?id=${id}`, {method: "DELETE"});
            const data = await res.json();
            if (res.ok) {
                setLinks((prev) => prev.filter((l) => l.id !== id));
            } else {
                console.error("Error al eliminar link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    }

    async function handleUpdateLink(id: string, updates: Partial<LinkData>) {
        try {
            const res = await fetch("/api/links", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id, ...updates }),
            });
            const data = await res.json();
            if (res.ok) {
                setLinks((prev) => prev.map((link) => (link.id === id ? {...link, ...data} : link)));
            } else {
                console.error("Error actualizando link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    }

    async function handleUpdateSection(id: string, updates: Partial<SectionData>) {
        try {
            const res = await fetch("/api/sections", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({id, ...updates}),
            });
            const data = await res.json();
            if (res.ok) {
                setSections((prev) => prev.map((sec) => (sec.id === id ? {...sec, ...data} : sec)));
            } else {
                console.error("Error al actualizar sección:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    }

    async function handleDeleteSection(id: string) {
        try {
            const linksToReassign = links.filter((l) => l.section_id === id);
            if (linksToReassign.length > 0) {
                const updates = linksToReassign.map((ln) => ({id: ln.id, section_id: null}));
                const patchRes = await fetch("/api/links", {
                    method: "PATCH",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify(updates),
                });
                const patchData = await patchRes.json();
                if (!patchRes.ok) {
                    console.error("Error reasignando links en backend:", patchData.error);
                }
            }
            setLinks((prev) => prev.map((link) => (link.section_id === id ? {...link, section_id: null} : link)));
            const res = await fetch(`/api/sections?id=${id}`, {method: "DELETE"});
            const data = await res.json();
            if (!res.ok) {
                console.error("Error al eliminar sección:", data.error);
                return;
            }
            setSections((prev) => prev.filter((sec) => sec.id !== id));
        } catch (error) {
            console.error("Error al eliminar sección:", error);
        }
    }

    return (
        <div className="flex flex-col md:flex-row min-h-screen">
            <div className="md:w-1/2 p-4 border-b md:border-b-0 md:border-r border-gray-600">
                <h1 className="text-2xl font-bold mb-4">Panel de Administración</h1>
                <MultiSectionsBoard
                    links={links}
                    setLinks={setLinks}
                    sections={sections}
                    setSections={setSections}
                    onUpdateLink={handleUpdateLink}
                    onDeleteLink={handleDeleteLink}
                    onUpdateSection={handleUpdateSection}
                    onDeleteSection={handleDeleteSection}
                />
                <SocialLinksPanel/>
            </div>
            <div className="md:w-1/2 p-4 bg-gray-900 flex flex-col items-center">
                <div className="bg-red-800 text-white p-2 rounded mb-4 w-full text-center">
                    <p className="font-bold">ESTO ES UNA PREVIEW</p>
                    <p className="text-sm">Así se verá tu landing</p>
                </div>
                <div className={'my-container'}>
                <div className="relative w-[320] h-[540px]">
                    <img
                        src="/images/iphone16-frame.png"
                        alt="iPhone frame"
                        className="absolute w-full h-full z-20 pointer-events-none"
                    />
                    <div
                        className="absolute top-[12px] left-[16px] w-[286px] h-[510px] z-10 overflow-y-auto bg-black rounded-t-3xl rounded-b-3xl">
                        <LandingPreview sections={sections} links={links}/>
                    </div>
                </div>
                </div>
            </div>
        </div>
    );
}



----- File: ./admin/multi-sections-container.tsx -----
"use client";

import {useEffect, useState} from "react";
import {useDroppable} from "@dnd-kit/core";
import {SortableContext, verticalListSortingStrategy} from "@dnd-kit/sortable";
import {LinkData, SectionData} from "./types";
import MultiSectionsItem from "./multi-sections-item";

function AddLink() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="size-5"
        >
            <path
                d="M10.75 4.75a.75.75 0 0 0-1.5 0v4.5h-4.5a.75.75 0 0 0 0 1.5h4.5v4.5a.75.75 0 0 0 1.5 0v-4.5h4.5a.75.75 0 0 0 0-1.5h-4.5v-4.5Z"/>
        </svg>
    );
}
function ArrowUpIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="size-5"
        >
            <path
                fillRule="evenodd"
                d="M9.47 6.47a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 1 1-1.06 1.06L10 8.06 6.28 11.78a.75.75 0 1 1-1.06-1.06l4.25-4.25Z"
                clipRule="evenodd"
            />
        </svg>
    );
}
function ArrowDownIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="size-5"
        >
            <path
                fillRule="evenodd"
                d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 13.06l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z"
                clipRule="evenodd"
            />
        </svg>
    );
}
function PencilIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="black"
            className="size-5"
        >
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931ZM19.5 7.125 16.862 4.487"
            />
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"
            />
        </svg>
    );
}
function TrashIcon() {
    return (
        <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="black"
            className="size-5"
        >
            <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673A2.25 2.25 0 0 1 15.916 21H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397M4.75 5.75h14.5"
            />
        </svg>
    );
}

interface MultiSectionsContainerProps {
    containerId: string;
    items: string[];
    links: LinkData[];
    sections: SectionData[];
    moveSectionUp: (sectionId: string) => void;
    moveSectionDown: (sectionId: string) => void;
    idx: number;
    total: number;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
    onDeleteLink: (id: string) => void;
    onCreateLinkInSection: (sectionId: string) => void;
    onUpdateSection: (id: string, updates: Partial<SectionData>) => void;
    onDeleteSection: (id: string) => void;
}

export default function MultiSectionsContainer({
                                                   containerId,
                                                   items,
                                                   links,
                                                   sections,
                                                   moveSectionUp,
                                                   moveSectionDown,
                                                   idx,
                                                   total,
                                                   onUpdateLink,
                                                   onDeleteLink,
                                                   onCreateLinkInSection,
                                                   onUpdateSection,
                                                   onDeleteSection,
                                               }: MultiSectionsContainerProps) {
    const { setNodeRef } = useDroppable({ id: containerId });
    const sec = sections.find((s) => s.id === containerId);
    const isNoSection = containerId === "no-section";
    const hideUp = idx === 0;
    const hideDown = idx === total - 1;
    const linkObjects = items.map((id) => links.find((l) => l.id === id)).filter(Boolean);

    const [isEditingSection, setIsEditingSection] = useState(false);
    const [editTitle, setEditTitle] = useState(sec?.title || "");
    const [showDeleteModalSection, setShowDeleteModalSection] = useState(false);

    useEffect(() => {
        if (sec) {
            setEditTitle(sec.title);
        }
    }, [sec]);

    function handleSaveSection() {
        if (!sec) return;
        onUpdateSection(sec.id, {title: editTitle});
        setIsEditingSection(false);
    }

    function handleCancelSection() {
        if (!sec) return;
        setIsEditingSection(false);
        setEditTitle(sec.title);
    }

    function handleDeleteClick() {
        setShowDeleteModalSection(true);
    }

    function confirmDeleteSection() {
        setShowDeleteModalSection(false);
        if (sec) {
            onDeleteSection(sec.id);
        }
    }

    function cancelDeleteSection() {
        setShowDeleteModalSection(false);
    }

    return (
        <div ref={setNodeRef} className="border border-purple-900 p-4 rounded bg-black">
            <div className="flex items-center justify-between mb-2">
                {isEditingSection && sec ? (
                    <div className="flex items-center gap-2">
                        <input
                            className="border rounded p-1"
                            value={editTitle}
                            onChange={(e) => setEditTitle(e.target.value)}
                        />
                        <button
                            onClick={handleSaveSection}
                            className="bg-green-600 text-white px-2 py-1 rounded"
                        >
                            Guardar
                        </button>
                        <button
                            onClick={handleCancelSection}
                            className="bg-gray-400 text-white px-2 py-1 rounded"
                        >
                            Cancelar
                        </button>
                    </div>
                ) : (
                    <h3 className="font-semibold text-lg">
                        {isNoSection ? "Sin Sección" : sec?.title}
                    </h3>
                )}

                {!isNoSection && sec && !isEditingSection && (
                    <div className="flex items-center gap-2">
                        {!hideUp && (
                            <button
                                onClick={() => moveSectionUp(sec.id)}
                                className="bg-black text-white rounded p-1"
                                aria-label="Subir sección"
                            >
                                <ArrowUpIcon/>
                            </button>
                        )}
                        {!hideDown && (
                            <button
                                onClick={() => moveSectionDown(sec.id)}
                                className="bg-black text-white rounded p-1"
                                aria-label="Bajar sección"
                            >
                                <ArrowDownIcon/>
                            </button>
                        )}
                        <button
                            onClick={() => onCreateLinkInSection(containerId)}
                            className="bg-black text-white rounded p-1 flex items-center gap-1"
                        >
                            <AddLink/>
                            <span className="hidden sm:inline">Link</span>
                        </button>
                        <button
                            onClick={() => setIsEditingSection(true)}
                            className="bg-gray-300 text-white px-1 py-1 rounded flex items-center gap-1"
                        >
                            <PencilIcon/>
                            {/*<span className="hidden sm:inline">Editar</span>*/}
                        </button>
                        <button
                            onClick={handleDeleteClick}
                            className="bg-gray-300 text-white px-1 py-1 rounded flex items-center"
                        >
                            <TrashIcon/>
                        </button>
                    </div>
                )}
            </div>

            <SortableContext items={items} strategy={verticalListSortingStrategy}>
                <ul className="space-y-2">
                    {linkObjects.map((link) => {
                        if (!link) return null;
                        return (
                            <MultiSectionsItem
                                key={link.id}
                                link={link}
                                onUpdateLink={onUpdateLink}
                                onDeleteLink={onDeleteLink}
                            />
                        );
                    })}
                </ul>
            </SortableContext>

            {items.length === 0 && (
                <p className="text-sm text-gray-400">Arrastra aquí enlaces para asignar</p>
            )}

            {showDeleteModalSection && (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
                    <div className="bg-black w-full max-w-sm mx-auto p-4 rounded shadow-lg">
                        <p className="mb-4">¿Seguro que deseas borrar esta sección?</p>
                        <div className="flex justify-end gap-2">
                            <button
                                onClick={cancelDeleteSection}
                                className="bg-gray-400 text-white px-3 py-1 rounded"
                            >
                                Cancelar
                            </button>
                            <button
                                onClick={confirmDeleteSection}
                                className="bg-red-600 text-white px-3 py-1 rounded"
                            >
                                Borrar
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}



----- File: ./extract-text.sh -----
#!/bin/bash
# Este script recorre recursivamente el directorio actual y, para cada archivo de tipo texto,
# añade una cabecera con la ruta y nombre del archivo y su contenido en project_content.txt

OUTPUT_FILE="project_content.txt"
# Limpiamos el archivo de salida si ya existe
> "$OUTPUT_FILE"

# Encuentra todos los archivos (omitimos directorios)
find . -type f | while IFS= read -r file; do
    # Usamos el comando 'file' para determinar el MIME type y comprobamos que empiece por "text/"
    mime=$(file -b --mime-type "$file")
    if [[ $mime == text/* ]]; then
        echo "----- File: $file -----" >> "$OUTPUT_FILE"
        cat "$file" >> "$OUTPUT_FILE"
        echo -e "\n\n" >> "$OUTPUT_FILE"
    fi
done

echo "Contenido extraído en: $OUTPUT_FILE"



----- File: ./layout.tsx -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ThemeProvider } from "@/components/theme-provider"; // Asegúrate de importar correctamente
import "./globals.css";

const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

const geistMono = Geist_Mono({
    variable: "--font-geist-mono",
    subsets: ["latin"],
});

export const metadata: Metadata = {
    title: "Create Next App",
    description: "Generated by create next app",
};

export default function RootLayout({
                                       children,
                                   }: Readonly<{ children: React.ReactNode }>) {
    return (
        <html lang="en" suppressHydrationWarning>
        <body
            className={`${geistSans.variable} ${geistMono.variable} antialiased`}
        >
        {/* Theme provider wraps the entire app */}
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
        >
            {children}
        </ThemeProvider>
        </body>
        </html>
    );
}



----- File: ./landing-content.tsx -----
// app/admin/landing-preview.tsx

"use client";

import {LinkData, SectionData} from "./admin/types";
import Header from "@/components/header";
import Section from "@/components/section";
import LinkButton from "@/components/link-button";
import SocialLinks from "@/components/SocialLinks";

interface LandingPreviewProps {
    sections: SectionData[];
    links: LinkData[];
}

/**
 * Este componente muestra la "landing" dentro del admin,
 * intentando ajustarse mejor a resoluciones pequeñas (ej. 320px de ancho).
 */
export default function LandingPreview({sections, links}: LandingPreviewProps) {
    return (
        <div className="w-full max-w-sm mx-auto bg-gradient-to-b from-black to-fuchsia-950 min-h-[500px] p-4">
            <Header
                name="Art0xDev"
                role="Full Stack Dev"
                description="¡Aprende programación desde 0 conmigo!"
                profileImage="https://cdn.campsite.bio/eyJidWNrZXQiOiJjYW1wc2l0ZS1iaW8tc3RvcmFnZSIsImtleSI6Im1lZGlhL3Byb2ZpbGUtaW1hZ2VzLzcyM2Q3MjU2LTU5MTMtNDA4Zi1hZTNiLTUyZDU2NDJhZDc4OC5qcGVnIiwiZWRpdHMiOnsicmVzaXplIjp7IndpZHRoIjoyMDB9fX0="
            />

            {/* Secciones con sus enlaces visibles */}
            {sections.map((sec) => {
                // Filtrar y ordenar enlaces de la sección
                const secLinks = links
                    .filter((l) => l.section_id === sec.id && l.visible)
                    .sort((a, b) => a.position - b.position);

                if (secLinks.length === 0) return null;

                return (
                    <Section key={sec.id} title={sec.title}>
                        {secLinks.map((link) => (
                            <LinkButton
                                key={link.id}
                                iconUrl={link.image || ""}
                                title={link.title}
                                url={link.url}
                            />
                        ))}
                    </Section>
                );
            })}

            <SocialLinks/>
        </div>
    );
}



----- File: ./api/sections/route.ts -----
// app/api/sections/route.ts
import { NextRequest, NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabase";

export async function GET() {
    const { data, error } = await supabaseAdmin
        .from("sections")
        .select("*")
        .order("position", { ascending: true });
    if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json(data, { status: 200 });
}

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const { title, position } = body;
        const { data, error } = await supabaseAdmin
            .from("sections")
            .insert([{ title, position }])
            .select();
        if (error) throw error;

        return NextResponse.json(data?.[0], { status: 201 });
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}

export async function PATCH(req: NextRequest) {
    try {
        const body = await req.json();
        if (Array.isArray(body)) {
            // Reordenar en masa
            const updates = body.map((sec) =>
                supabaseAdmin.from("sections").update({ position: sec.position }).eq("id", sec.id)
            );
            const results = await Promise.all(updates);
            const anyError = results.find((r) => r.error);
            if (anyError?.error) throw new Error(anyError.error.message);
            return NextResponse.json({ message: "Sections reordered" }, { status: 200 });
        } else {
            // Update individual
            const { id, ...rest } = body;
            const { data, error } = await supabaseAdmin
                .from("sections")
                .update(rest)
                .eq("id", id)
                .select();
            if (error) throw error;
            return NextResponse.json(data?.[0], { status: 200 });
        }
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}

export async function DELETE(req: NextRequest) {
    try {
        const { searchParams } = new URL(req.url);
        const id = searchParams.get("id");
        if (!id) {
            return NextResponse.json({ error: "Missing id" }, { status: 400 });
        }
        const { error } = await supabaseAdmin.from("sections").delete().eq("id", id);
        if (error) throw error;

        return NextResponse.json({ message: "Section deleted" }, { status: 200 });
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}



----- File: ./api/social-links/route.ts -----
import { NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabase"; // Ajusta la ruta a tu helper

// GET => obtener lista
export async function GET() {
    const { data, error } = await supabaseAdmin
        .from("social_links")
        .select("*")
        .order("position", { ascending: true });
    if (error) {
        return NextResponse.json({ error: error.message }, { status: 400 });
    }
    return NextResponse.json(data);
}

// POST => crear
export async function POST(request: Request) {
    const body = await request.json();
    // { name, url, visible, position? }
    const { data, error } = await supabaseAdmin
        .from("social_links")
        .insert({
            name: body.name,
            url: body.url,
            visible: body.visible,
            position: body.position ?? 0,
        })
        .select("*")
        .single();
    if (error) {
        return NextResponse.json({ error: error.message }, { status: 400 });
    }
    return NextResponse.json(data);
}

// PATCH => reorden masivo (con multiple updates)
export async function PATCH(request: Request) {
    const body = await request.json();

    if (Array.isArray(body)) {
        // Reorden masivo
        for (const item of body) {
            // item: { id, position }
            const { error } = await supabaseAdmin
                .from("social_links")
                .update({ position: item.position })
                .eq("id", item.id);
            if (error) {
                return NextResponse.json({ error: error.message }, { status: 400 });
            }
        }
        return NextResponse.json({ success: true });
    } else {
        // update individual (como antes)
        const { id, ...rest } = body;
        if (!id) {
            return NextResponse.json({ error: "No ID provided" }, { status: 400 });
        }
        const { data, error } = await supabaseAdmin
            .from("social_links")
            .update(rest)
            .eq("id", id)
            .select("*")
            .single();
        if (error) {
            return NextResponse.json({ error: error.message }, { status: 400 });
        }
        return NextResponse.json(data);
    }
}



----- File: ./api/links/route.ts -----
// app/api/links/route.ts
import {NextRequest, NextResponse} from "next/server";
import {supabaseAdmin} from "@/lib/supabase";

// GET: obtener lista de enlaces ordenados
export async function GET() {
    const { data, error } = await supabaseAdmin
        .from("links")
        .select("*")
        .order("position", { ascending: true });
    if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json(data, { status: 200 });
}

// POST: crear un nuevo enlace
export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const { title, url, image, visible, position, section_id } = body;

        const { data, error } = await supabaseAdmin
            .from("links")
            .insert([{ title, url, image, visible, position, section_id }])
            .select();
        if (error) throw error;

        return NextResponse.json(data?.[0], { status: 201 });
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}

// PATCH: reordenar en masa O actualizar un enlace individual
export async function PATCH(req: NextRequest) {
    try {
        const body = await req.json();

        // Si recibimos un array => updates masivos (ej. reordenar, reasignar section_id, etc.)
        if (Array.isArray(body)) {
            // Hacemos un Promise.all para procesar cada item
            const results = await Promise.all(
                body.map((item) =>
                    supabaseAdmin
                        .from("links")
                        .update(item)       // <-- Aquí usamos todo el objeto, para que "section_id: null" se aplique
                        .eq("id", item.id)
                        .select()
                )
            );
            // Ver si hay algún error
            const anyError = results.find((r) => r.error);
            if (anyError?.error) throw new Error(anyError.error.message);

            // Recopilamos la data actualizada
            const allData = results.flatMap((r) => r.data ?? []);
            return NextResponse.json(allData, {status: 200});
        } else {
            // PATCH individual
            const { id, ...rest } = body;
            if (!id) {
                return NextResponse.json({error: "No ID provided"}, {status: 400});
            }

            // Actualizamos el enlace con los campos que nos lleguen (title, url, section_id, etc.)
            const { data, error } = await supabaseAdmin
                .from("links")
                .update(rest)
                .eq("id", id)
                .select();
            if (error) throw error;

            return NextResponse.json(data?.[0], { status: 200 });
        }
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}

// DELETE: borrar un enlace
export async function DELETE(req: NextRequest) {
    try {
        const { searchParams } = new URL(req.url);
        const id = searchParams.get("id");
        if (!id) {
            return NextResponse.json({ error: "Missing id" }, { status: 400 });
        }

        const {error} = await supabaseAdmin
            .from("links")
            .delete()
            .eq("id", id);
        if (error) throw error;

        return NextResponse.json({ message: "Link deleted" }, { status: 200 });
    } catch (error: any) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}



----- File: ./page.tsx -----
// app/page.tsx
import {supabaseAdmin} from "@/lib/supabase";
import {LinkData, SectionData} from "./admin/types";
import LandingPreview from "@/app/landing-content";

export default async function Home() {
    // Cargar secciones
    const { data: sectionsData, error: secError } = await supabaseAdmin
        .from("sections")
        .select("*")
        .order("position", { ascending: true });

    // Cargar enlaces
    const { data: linksData, error: linksError } = await supabaseAdmin
        .from("links")
        .select("*")
        .order("position", {ascending: true});

    // Manejo de errores
    if (secError) console.error("Error fetching sections:", secError.message);
    if (linksError) console.error("Error fetching links:", linksError.message);

    const sections = (sectionsData as SectionData[]) || [];
    const links = (linksData as LinkData[]) || [];

    return (
        <div className="min-h-screen bg-gradient-to-b from-black to-fuchsia-950 p-4">
            <LandingPreview sections={sections} links={links}/>
        </div>
    );
}



----- File: ./globals.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

.dark {
  --background: #0a0a0a;
  --foreground: #ededed;
}

body {
  color: var(--foreground);
  background-color: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
}

/* ====== EJEMPLO: container queries ====== */
@layer utilities {
  /* 1) Declaras una clase que se comporta como contenedor */
  .my-container {
    @container size;
    /* “size” indica que las queries se basan en su ancho y alto (block+inline).
       También puedes usar “inline-size” o “normal” según tu caso. */
  }
}



