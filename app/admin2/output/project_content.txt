----- File: ./non-pinned-list.tsx -----
"use client";

import { DndContext, DragEndEvent, useSensor, useSensors } from "@dnd-kit/core";
import { PointerSensor, KeyboardSensor, closestCenter } from "@dnd-kit/core";
import { SortableContext, verticalListSortingStrategy, arrayMove } from "@dnd-kit/sortable";

import { LinkData } from "./types";
import { SortableItem } from "./sortable-items";

interface NonPinnedListProps {
    normalLinks: LinkData[];
    editingLinkId: string | null;
    editingTitle: string;
    editingUrl: string;
    setEditingTitle: (val: string) => void;  // <--
    setEditingUrl: (val: string) => void;    // <--
    onStartEditing: (link: LinkData) => void;
    onSaveEditing: (id: string) => void;
    onCancelEditing: () => void;
    onDelete: (id: string) => void;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
    onReorder: (newLinks: LinkData[]) => void;
}

export function NonPinnedList({
                                  normalLinks,
                                  editingLinkId,
                                  editingTitle,
                                  editingUrl,
                                  setEditingTitle,
                                  setEditingUrl,
                                  onStartEditing,
                                  onSaveEditing,
                                  onCancelEditing,
                                  onDelete,
                                  onUpdateLink,
                                  onReorder,
                              }: NonPinnedListProps) {
    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor)
    );

    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event;
        if (!over || active.id === over.id) return;

        const oldIndex = normalLinks.findIndex((l) => l.id === active.id);
        const newIndex = normalLinks.findIndex((l) => l.id === over.id);
        if (oldIndex < 0 || newIndex < 0) return;

        const newArray = arrayMove(normalLinks, oldIndex, newIndex);
        const updated = newArray.map((link, idx) => ({ ...link, position: idx }));

        onReorder(updated);
    };

    return (
        <div>
            <h2 className="font-semibold mb-2">Enlaces No Pinned (Drag & Drop)</h2>
            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext items={normalLinks.map((l) => l.id)} strategy={verticalListSortingStrategy}>
                    <ul className="space-y-2">
                        {normalLinks.map((link) => (
                            <SortableItem
                                key={link.id}
                                link={link}
                                editingLinkId={editingLinkId}
                                editingTitle={editingTitle}
                                editingUrl={editingUrl}
                                setEditingTitle={setEditingTitle}  // <--
                                setEditingUrl={setEditingUrl}       // <--
                                onStartEditing={onStartEditing}
                                onSaveEditing={onSaveEditing}
                                onCancelEditing={onCancelEditing}
                                onDelete={onDelete}
                                onUpdateLink={onUpdateLink}
                            />
                        ))}
                    </ul>
                </SortableContext>
            </DndContext>
        </div>
    );
}



----- File: ./multi-sections-board.tsx -----
"use client";

import { useEffect, useState } from "react";
import {
    DndContext,
    DragEndEvent,
    PointerSensor,
    KeyboardSensor,
    useSensor,
    useSensors,
    closestCenter,
} from "@dnd-kit/core";
import {
    SortableContext,
    verticalListSortingStrategy,
} from "@dnd-kit/sortable";

import { LinkData, SectionData } from "./types";
import MultiSectionsContainer from "./multi-sections-container";

/**
 * Board de contenedores:
 * - "no-section" para enlaces no pinned y sin section_id
 * - uno para cada sección
 * Permite arrastrar un enlace dentro de la misma sección (reordenar)
 * y moverlo a otra sección, corrigiendo el bug de arrastrar hacia abajo.
 */
interface MultiSectionsBoardProps {
    links: LinkData[];
    setLinks: (val: LinkData[]) => void;
    sections: SectionData[];
}

export default function MultiSectionsBoard({
                                               links,
                                               setLinks,
                                               sections,
                                           }: MultiSectionsBoardProps) {
    // Estado local de contenedores (id + items)
    const [containers, setContainers] = useState<{ id: string; items: string[] }[]>([]);

    useEffect(() => {
        // Construir contenedores
        const noSectionItems = links
            .filter((l) => !l.pinned && !l.section_id)
            .sort((a, b) => a.position - b.position)
            .map((l) => l.id);

        const newContainers = [
            {
                id: "no-section",
                items: noSectionItems,
            },
            ...sections
                .sort((a, b) => a.position - b.position)
                .map((sec) => {
                    const secItems = links
                        .filter((l) => !l.pinned && l.section_id === sec.id)
                        .sort((a, b) => a.position - b.position)
                        .map((l) => l.id);
                    return {
                        id: sec.id,
                        items: secItems,
                    };
                }),
        ];

        setContainers(newContainers);
    }, [links, sections]);

    // Sensores dnd-kit
    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor)
    );

    // =====================
    // handleDragEnd
    // =====================
    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event;
        if (!over) return;

        // Contenedor origen
        const activeContainer = containers.find((c) => c.items.includes(active.id));
        // Contenedor destino
        const overContainer =
            containers.find((c) => c.items.includes(over.id)) ||
            containers.find((c) => c.id === over.id);

        if (!activeContainer || !overContainer) return;

        // Si arrastramos sobre el mismo item
        if (activeContainer.id === overContainer.id && active.id === over.id) {
            return;
        }

        // Clonar contenedores
        const newContainers = structuredClone(containers);

        const fromIndex = newContainers.findIndex((c) => c.id === activeContainer.id);
        const toIndex = newContainers.findIndex((c) => c.id === overContainer.id);

        const fromItems = newContainers[fromIndex].items;
        const toItems = newContainers[toIndex].items;

        const oldIndex = fromItems.indexOf(active.id);
        let newIndex = toItems.indexOf(over.id);

        // Si arrastramos a un contenedor vacío o al final
        if (newIndex === -1) {
            newIndex = toItems.length;
        }

        // ============================
        // Caso 1: Mismo contenedor
        // ============================
        if (activeContainer.id === overContainer.id) {
            // Mover dentro de la misma sección
            // Si oldIndex < newIndex => al quitar el item,
            // la lista se acorta y newIndex se desplaza
            if (oldIndex < newIndex) {
                newIndex--;
            }
            // Extraer item y volver a insertarlo en la posición newIndex
            const itemId = fromItems[oldIndex];
            fromItems.splice(oldIndex, 1);
            fromItems.splice(newIndex, 0, itemId);

            // Reordenar local + DB
            reorderLinksInContainer(fromItems, activeContainer.id);

        } else {
            // ============================
            // Caso 2: Mover a otro contenedor
            // ============================
            // Quitar del contenedor original
            fromItems.splice(oldIndex, 1);
            // Insertar en el contenedor destino
            toItems.splice(newIndex, 0, active.id);

            // Actualizar section_id en DB + local
            updateLinkContainer(active.id, overContainer.id);

            // Reordenar local + DB en ambos contenedores
            reorderLinksInContainer(toItems, overContainer.id);
            reorderLinksInContainer(fromItems, activeContainer.id);
        }

        setContainers(newContainers);
    };

    // =====================
    // updateLinkContainer
    // =====================
    /**
     * Cambia section_id (o null si "no-section") y pinned=false en la DB y en local
     */
    async function updateLinkContainer(linkId: string, containerId: string) {
        const section_id = containerId === "no-section" ? null : containerId;

        // 1. Actualizar local
        setLinks((prev) => {
            const newLinks = structuredClone(prev);
            const link = newLinks.find((l) => l.id === linkId);
            if (link) {
                link.section_id = section_id;
                link.pinned = false;
            }
            return newLinks;
        });

        // 2. PATCH al servidor
        await fetch("/api/links", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id: linkId, section_id, pinned: false }),
        });
    }

    // =====================
    // reorderLinksInContainer
    // =====================
    /**
     * Reordena localmente la position de los itemIds y hace PATCH masivo
     */
    async function reorderLinksInContainer(itemIds: string[], containerId: string) {
        // 1. Actualizar local
        setLinks((prev) => {
            const newLinks = structuredClone(prev);
            itemIds.forEach((id, idx) => {
                const link = newLinks.find((l) => l.id === id);
                if (link) {
                    link.position = idx;
                }
            });
            return newLinks;
        });

        // 2. PATCH en masa
        const updates = itemIds.map((id, idx) => ({
            id,
            position: idx,
        }));
        await fetch("/api/links", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(updates),
        });
    }

    // =====================
    // RENDER
    // =====================
    return (
        <div className="mt-8">
            <h2 className="font-semibold mb-2">Enlaces No Pinned (Drag & Drop por Secciones)</h2>
            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                {/* SortableContext para contenedores, si deseas reordenarlos
            o simplemente para anidar. */}
                <SortableContext items={containers.map((c) => c.id)} strategy={verticalListSortingStrategy}>
                    <div className="flex flex-col gap-6">
                        {containers.map((container) => (
                            <MultiSectionsContainer
                                key={container.id}
                                containerId={container.id}
                                items={container.items}
                                links={links}
                                sections={sections}
                            />
                        ))}
                    </div>
                </SortableContext>
            </DndContext>
        </div>
    );
}



----- File: ./extract-text.sh -----
#!/bin/bash
# Este script recorre recursivamente el directorio actual y, para cada archivo de tipo texto,
# añade una cabecera con la ruta y nombre del archivo y su contenido en output/project_content.txt.
# Se excluye el directorio 'output' para evitar procesar el archivo de salida.

OUTPUT_DIR="./output"
OUTPUT_FILE="$OUTPUT_DIR/project_content.txt"

# Creamos el directorio de salida si no existe
mkdir -p "$OUTPUT_DIR"

# Limpiamos el archivo de salida si ya existe
> "$OUTPUT_FILE"

# Encuentra todos los archivos, excluyendo el directorio de salida para evitar procesarlo
find . -path "$OUTPUT_DIR" -prune -o -type f -print | while IFS= read -r file; do
    # Usamos 'file' para determinar el MIME type y comprobamos que empiece por "text/"
    mime=$(file -b --mime-type "$file")
    if [[ $mime == text/* ]]; then
        echo "----- File: $file -----" >> "$OUTPUT_FILE"
        cat "$file" >> "$OUTPUT_FILE"
        echo -e "\n\n" >> "$OUTPUT_FILE"
    fi
done

echo "Contenido extraído en: $OUTPUT_FILE"



----- File: ./sections-panel-item.tsx -----
"use client";

import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { Button } from "@/components/ui/button";
import { SectionData } from "./types";

interface SectionsPanelItemProps {
  section: SectionData; // <-- nombre EXACTO
  onDeleteSection: (id: string) => void;
  onUpdateSection: (id: string, updates: Partial<SectionData>) => void;
}

export default function SectionsPanelItem({
                                            section,
                                            onDeleteSection,
                                            onUpdateSection,
                                          }: SectionsPanelItemProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: section.id }); // <-- "section.id" no será undefined si "section" existe

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    background: isDragging ? "rgba(255,255,255,0.1)" : "transparent",
  };

  const handleRename = () => {
    const newTitle = prompt("Nuevo título de la sección:", section.title);
    if (newTitle && newTitle.trim() !== "") {
      onUpdateSection(section.id, { title: newTitle.trim() });
    }
  };

  return (
      <li
          ref={setNodeRef}
          style={style}
          className="flex items-center justify-between p-2 border rounded"
      >
        <div
            className="cursor-grab px-2 select-none text-sm bg-gray-700 text-white rounded mr-2"
            {...attributes}
            {...listeners}
        >
          ☰
        </div>
        <div className="flex-1">
          <div className="font-semibold">{section.title}</div>
        </div>
        <Button variant="secondary" onClick={handleRename}>
          Renombrar
        </Button>
        <Button variant="destructive" onClick={() => onDeleteSection(section.id)}>
          Eliminar
        </Button>
      </li>
  );
}



----- File: ./sortable-items.tsx -----
"use client";

import { CSS } from "@dnd-kit/utilities";
import { useSortable } from "@dnd-kit/sortable";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { LinkData } from "./types";

interface SortableItemProps {
    link: LinkData;
    editingLinkId: string | null;
    editingTitle: string;
    editingUrl: string;
    setEditingTitle: (val: string) => void;  // <--
    setEditingUrl: (val: string) => void;    // <--
    onStartEditing: (link: LinkData) => void;
    onSaveEditing: (id: string) => void;
    onCancelEditing: () => void;
    onDelete: (id: string) => void;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
}

export function SortableItem({
                                 link,
                                 editingLinkId,
                                 editingTitle,
                                 editingUrl,
                                 setEditingTitle,
                                 setEditingUrl,
                                 onStartEditing,
                                 onSaveEditing,
                                 onCancelEditing,
                                 onDelete,
                                 onUpdateLink,
                             }: SortableItemProps) {
    const { attributes, listeners, setNodeRef, transform, transition, isDragging } =
        useSortable({ id: link.id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        background: isDragging ? "rgba(255,255,255,0.1)" : "transparent",
    };

    const isEditing = editingLinkId === link.id;

    return (
        <li
            ref={setNodeRef}
            style={style}
            className="flex items-center justify-between p-2 border rounded"
        >
            {/* Drag handle */}
            <div
                className="cursor-grab px-2 select-none text-sm text-gray-300 bg-gray-700 rounded mr-2"
                {...attributes}
                {...listeners}
            >
                Arrastra
            </div>

            {isEditing ? (
                <div className="flex-1 flex flex-col gap-2">
                    <Input
                        value={editingTitle}
                        onChange={(e) => setEditingTitle(e.target.value)}
                    />
                    <Input
                        value={editingUrl}
                        onChange={(e) => setEditingUrl(e.target.value)}
                    />
                </div>
            ) : (
                <div className="flex items-center gap-4 flex-1">
                    {link.image && (
                        <img
                            src={link.image}
                            alt={link.title}
                            className="w-10 h-10 object-cover rounded"
                        />
                    )}
                    <div>
                        <div className="font-semibold">{link.title}</div>
                        <div className="text-sm text-gray-600">{link.url}</div>
                    </div>
                </div>
            )}

            <div className="flex items-center gap-2">
                <div className="flex items-center gap-1">
                    <label className="text-sm">Visible</label>
                    <Switch
                        className="data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-red-500"
                        checked={link.visible}
                        onCheckedChange={(checked) => onUpdateLink(link.id, { visible: checked })}
                    />
                </div>
                <div className="flex items-center gap-1">
                    <label className="text-sm">Pinned</label>
                    <Switch
                        className="data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-red-500"
                        checked={link.pinned}
                        onCheckedChange={(checked) => onUpdateLink(link.id, { pinned: checked })}
                    />
                </div>

                {isEditing ? (
                    <>
                        <Button variant="secondary" onClick={() => onSaveEditing(link.id)}>
                            Guardar
                        </Button>
                        <Button variant="destructive" onClick={onCancelEditing}>
                            Cancelar
                        </Button>
                    </>
                ) : (
                    <>
                        <Button variant="secondary" onClick={() => onStartEditing(link)}>
                            Editar
                        </Button>
                        <Button variant="destructive" onClick={() => onDelete(link.id)}>
                            Eliminar
                        </Button>
                    </>
                )}
            </div>
        </li>
    );
}



----- File: ./types.ts -----
// app/admin/types.ts

export interface LinkData {
    id: string;
    title: string;
    url: string;
    image?: string;
    visible: boolean;
    pinned: boolean;
    position: number;
    section_id?: string | null;
}

export interface SectionData {
    id: string;
    title: string;
    position: number;
}



----- File: ./pinned-list.tsx -----
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { LinkData } from "./types";

interface PinnedListProps {
    pinnedLinks: LinkData[];
    editingLinkId: string | null;
    editingTitle: string;
    editingUrl: string;
    setEditingTitle: (val: string) => void;  // <--
    setEditingUrl: (val: string) => void;    // <--
    onStartEditing: (link: LinkData) => void;
    onSaveEditing: (id: string) => void;
    onCancelEditing: () => void;
    onDelete: (id: string) => void;
    onUpdateLink: (id: string, updates: Partial<LinkData>) => void;
}

export function PinnedList({
                               pinnedLinks,
                               editingLinkId,
                               editingTitle,
                               editingUrl,
                               setEditingTitle,
                               setEditingUrl,
                               onStartEditing,
                               onSaveEditing,
                               onCancelEditing,
                               onDelete,
                               onUpdateLink,
                           }: PinnedListProps) {
    return (
        <div className="mb-8">
            <h2 className="font-semibold mb-2">Enlaces Pinned (sin drag)</h2>
            <ul className="space-y-2">
                {pinnedLinks.map((link) => {
                    const isEditing = editingLinkId === link.id;

                    return (
                        <li
                            key={link.id}
                            className="flex items-center justify-between p-2 border rounded"
                        >
                            {isEditing ? (
                                <div className="flex-1 flex flex-col gap-2">
                                    <Input
                                        value={editingTitle}
                                        onChange={(e) => setEditingTitle(e.target.value)}
                                    />
                                    <Input
                                        value={editingUrl}
                                        onChange={(e) => setEditingUrl(e.target.value)}
                                    />
                                </div>
                            ) : (
                                <div className="flex items-center gap-4">
                                    {link.image && (
                                        <img
                                            src={link.image}
                                            alt={link.title}
                                            className="w-10 h-10 object-cover rounded"
                                        />
                                    )}
                                    <div>
                                        <div className="font-semibold">{link.title}</div>
                                        <div className="text-sm text-gray-600">{link.url}</div>
                                    </div>
                                </div>
                            )}

                            <div className="flex items-center gap-2">
                                <div className="flex items-center gap-1">
                                    <label className="text-sm">Visible</label>
                                    <Switch
                                        className="
                      data-[state=checked]:bg-green-500
                      data-[state=unchecked]:bg-red-500
                    "
                                        checked={link.visible}
                                        onCheckedChange={(checked) =>
                                            onUpdateLink(link.id, { visible: checked })
                                        }
                                    />
                                </div>
                                <div className="flex items-center gap-1">
                                    <label className="text-sm">Pinned</label>
                                    <Switch
                                        className="
                      data-[state=checked]:bg-green-500
                      data-[state=unchecked]:bg-red-500
                    "
                                        checked={link.pinned}
                                        onCheckedChange={(checked) =>
                                            onUpdateLink(link.id, { pinned: checked })
                                        }
                                    />
                                </div>

                                {isEditing ? (
                                    <>
                                        <Button variant="secondary" onClick={() => onSaveEditing(link.id)}>
                                            Guardar
                                        </Button>
                                        <Button variant="destructive" onClick={onCancelEditing}>
                                            Cancelar
                                        </Button>
                                    </>
                                ) : (
                                    <>
                                        <Button variant="secondary" onClick={() => onStartEditing(link)}>
                                            Editar
                                        </Button>
                                        <Button variant="destructive" onClick={() => onDelete(link.id)}>
                                            Eliminar
                                        </Button>
                                    </>
                                )}
                            </div>
                        </li>
                    );
                })}
            </ul>
        </div>
    );
}



----- File: ./sections-panel.tsx -----
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

import {
    DndContext,
    DragEndEvent,
    PointerSensor,
    KeyboardSensor,
    useSensor,
    useSensors,
    closestCenter,
} from "@dnd-kit/core";
import {
    SortableContext,
    verticalListSortingStrategy,
    arrayMove,
} from "@dnd-kit/sortable";

import SectionsPanelItem from "./sections-panel-item"; // <-- Ajusta la ruta
import { SectionData } from "./types";

/**
 * Muestra un panel para:
 * - Cargar secciones (GET /api/sections)
 * - Crear secciones (POST /api/sections)
 * - Reordenar secciones (PATCH /api/sections con array)
 * - Renombrar / eliminar cada sección
 */
export default function SectionsPanel() {
    const [sections, setSections] = useState<SectionData[]>([]);
    const [newSectionTitle, setNewSectionTitle] = useState("");

    // Cargar secciones al montar
    useEffect(() => {
        fetch("/api/sections")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) {
                    setSections(data);
                }
            })
            .catch((err) => console.error("Error fetching sections:", err));
    }, []);

    // Crear sección
    const handleCreateSection = async () => {
        if (!newSectionTitle.trim()) return;
        try {
            const res = await fetch("/api/sections", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    title: newSectionTitle.trim(),
                    position: sections.length, // la ponemos al final
                }),
            });
            const data = await res.json();
            if (res.ok) {
                setSections((prev) => [...prev, data]);
                setNewSectionTitle("");
            } else {
                console.error("Error creando sección:", data.error);
            }
        } catch (error) {
            console.error("Error creando sección:", error);
        }
    };

    // Eliminar sección
    const handleDeleteSection = async (id: string) => {
        try {
            const res = await fetch(`/api/sections?id=${id}`, { method: "DELETE" });
            const data = await res.json();
            if (res.ok) {
                setSections((prev) => prev.filter((sec) => sec.id !== id));
            } else {
                console.error("Error eliminando sección:", data.error);
            }
        } catch (error) {
            console.error("Error eliminando sección:", error);
        }
    };

    // Editar (renombrar) sección
    const handleUpdateSection = async (id: string, updates: Partial<SectionData>) => {
        try {
            const res = await fetch("/api/sections", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id, ...updates }),
            });
            const data = await res.json();
            if (res.ok) {
                setSections((prev) =>
                    prev.map((sec) => (sec.id === id ? { ...sec, ...data } : sec))
                );
            } else {
                console.error("Error actualizando sección:", data.error);
            }
        } catch (error) {
            console.error("Error actualizando sección:", error);
        }
    };

    // DndKit sensors
    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor)
    );

    // Reordenar secciones con drag & drop
    const handleDragEnd = async (event: DragEndEvent) => {
        const { active, over } = event;
        if (!over || active.id === over.id) return;

        const oldIndex = sections.findIndex((s) => s.id === active.id);
        const newIndex = sections.findIndex((s) => s.id === over.id);
        if (oldIndex < 0 || newIndex < 0) return;

        const newArr = arrayMove(sections, oldIndex, newIndex);
        // reasignar position localmente
        const updated = newArr.map((s, idx) => ({ ...s, position: idx }));
        setSections(updated);

        // PATCH en masa a /api/sections
        const res = await fetch("/api/sections", {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(updated.map((s) => ({ id: s.id, position: s.position }))),
        });
        if (!res.ok) {
            const data = await res.json();
            console.error("Error reordenando secciones:", data.error);
        }
    };

    return (
        <div className="border p-4 my-8">
            <h2 className="text-xl font-semibold mb-4">Administrar Secciones</h2>

            {/* Crear Sección */}
            <div className="flex items-center gap-2 mb-4">
                <Input
                    placeholder="Título de la sección"
                    value={newSectionTitle}
                    onChange={(e) => setNewSectionTitle(e.target.value)}
                />
                <Button onClick={handleCreateSection}>Crear Sección</Button>
            </div>

            {/* Lista de secciones con drag & drop */}
            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext items={sections.map((s) => s.id)} strategy={verticalListSortingStrategy}>
                    <ul className="space-y-2">
                        {sections.map((sec) => (
                            <SectionsPanelItem
                                key={sec.id}
                                section={sec}
                                onDeleteSection={handleDeleteSection}
                                onUpdateSection={handleUpdateSection}
                            />
                        ))}
                    </ul>
                </SortableContext>
            </DndContext>
        </div>
    );
}



----- File: ./multi-sections-item.tsx -----
"use client";

import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { LinkData } from "./types";

interface MultiSectionsItemProps {
    link: LinkData;
}

export default function MultiSectionsItem({ link }: MultiSectionsItemProps) {
    const { attributes, listeners, setNodeRef, transform, transition, isDragging } =
        useSortable({ id: link.id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.6 : undefined,
    };

    return (
        <li
            ref={setNodeRef}
            style={style}
            className="flex items-center gap-2 p-2 border rounded bg-white/10"
            {...attributes}
            {...listeners}
        >
            <div className="cursor-grab text-sm text-gray-300">↕</div>
            <div>
                <div className="font-semibold">{link.title}</div>
                <div className="text-xs text-gray-400">{link.url}</div>
            </div>
        </li>
    );
}



----- File: ./creation-form.tsx -----
// app/admin/CreationForm.tsx
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { LinkData, SectionData } from "./types";

interface CreationFormProps {
    newLink: Omit<LinkData, "id">;
    setNewLink: (val: Omit<LinkData, "id">) => void;
    onCreate: () => void;
    sections: SectionData[]; // <-- Lista de secciones para asignar section_id
}

export function CreationForm({
                                 newLink,
                                 setNewLink,
                                 onCreate,
                                 sections,
                             }: CreationFormProps) {
    return (
        <div className="border p-4 mb-8 space-y-2">
            <h2 className="font-semibold">Crear Enlace</h2>
            <Input
                placeholder="Título"
                value={newLink.title}
                onChange={(e) => setNewLink({ ...newLink, title: e.target.value })}
            />
            <Input
                placeholder="URL"
                value={newLink.url}
                onChange={(e) => setNewLink({ ...newLink, url: e.target.value })}
            />
            <Input
                placeholder="Imagen (URL)"
                value={newLink.image || ""}
                onChange={(e) => setNewLink({ ...newLink, image: e.target.value })}
            />

            <div className="flex items-center gap-2">
                <label className="text-sm">Visible:</label>
                <Switch
                    checked={newLink.visible}
                    onCheckedChange={(checked) =>
                        setNewLink({ ...newLink, visible: checked })
                    }
                />
            </div>
            <div className="flex items-center gap-2">
                <label className="text-sm">Pinned:</label>
                <Switch
                    checked={newLink.pinned}
                    onCheckedChange={(checked) =>
                        setNewLink({ ...newLink, pinned: checked })
                    }
                />
            </div>

            {/* SELECT DE SECCIONES */}
            <div className="flex items-center gap-2">
                <label className="text-sm">Sección:</label>
                <select
                    className="border rounded p-1"
                    value={newLink.section_id || ""}
                    onChange={(e) =>
                        setNewLink({
                            ...newLink,
                            section_id: e.target.value === "" ? null : e.target.value,
                        })
                    }
                >
                    <option value="">(Sin sección)</option>
                    {sections.map((sec) => (
                        <option key={sec.id} value={sec.id}>
                            {sec.title}
                        </option>
                    ))}
                </select>
            </div>

            <Button onClick={onCreate}>Crear</Button>
        </div>
    );
}



----- File: ./page.tsx -----
"use client";

import { useEffect, useState } from "react";
import { LinkData, SectionData } from "./types";
import { CreationForm } from "./creation-form";
import { PinnedList } from "./pinned-list";
import { NonPinnedList } from "./non-pinned-list";
import SectionsPanel from "./sections-panel"; // Ajusta ruta
import SectionsWithLinksBoard from "./sections-with-links-board"; // <-- Nuevo
import MultiSectionsBoard from "./multi-sections-board"; // Ajusta ruta

export default function AdminPage() {
    // =======================
    // ESTADO DE ENLACES
    // =======================
    const [links, setLinks] = useState<LinkData[]>([]);
    const [newLink, setNewLink] = useState<Omit<LinkData, "id">>({
        title: "",
        url: "",
        image: "",
        visible: true,
        pinned: false,
        position: 0,
        section_id: null,
    });

    // Edición inline
    const [editingLinkId, setEditingLinkId] = useState<string | null>(null);
    const [editingTitle, setEditingTitle] = useState("");
    const [editingUrl, setEditingUrl] = useState("");

    // =======================
    // ESTADO DE SECCIONES
    // =======================
    const [sections, setSections] = useState<SectionData[]>([]);

    // Cargar links y sections
    useEffect(() => {
        // Cargar links
        fetch("/api/links")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) {
                    setLinks(data);
                }
            })
            .catch((err) => console.error(err));

        // Cargar sections
        fetch("/api/sections")
            .then((res) => res.json())
            .then((data) => {
                if (Array.isArray(data)) {
                    setSections(data);
                }
            })
            .catch((err) => console.error(err));
    }, []);

    // =======================
    // FUNCIONES LINKS
    // =======================
    const handleCreate = async () => {
        try {
            const res = await fetch("/api/links", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(newLink),
            });
            const data = await res.json();

            if (res.ok) {
                setLinks((prev) => [...prev, data]);
                setNewLink({
                    title: "",
                    url: "",
                    image: "",
                    visible: true,
                    pinned: false,
                    position: 0,
                    section_id: null,
                });
            } else {
                console.error("Error al crear link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    };

    const handleDelete = async (id: string) => {
        try {
            const res = await fetch(`/api/links?id=${id}`, { method: "DELETE" });
            const data = await res.json();

            if (res.ok) {
                setLinks((prev) => prev.filter((l) => l.id !== id));
            } else {
                console.error("Error al eliminar link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    };

    const handleUpdateLink = async (id: string, updates: Partial<LinkData>) => {
        try {
            const res = await fetch("/api/links", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id, ...updates }),
            });
            const data = await res.json();

            if (res.ok) {
                setLinks((prev) =>
                    prev.map((link) => (link.id === id ? { ...link, ...data } : link))
                );
            } else {
                console.error("Error al actualizar link:", data.error);
            }
        } catch (error) {
            console.error(error);
        }
    };

    // Edición inline
    const startEditing = (link: LinkData) => {
        setEditingLinkId(link.id);
        setEditingTitle(link.title);
        setEditingUrl(link.url);
    };

    const saveEditing = async (id: string) => {
        await handleUpdateLink(id, { title: editingTitle, url: editingUrl });
        setEditingLinkId(null);
        setEditingTitle("");
        setEditingUrl("");
    };

    const cancelEditing = () => {
        setEditingLinkId(null);
        setEditingTitle("");
        setEditingUrl("");
    };

    // Reordenar no pinned
    const handleReorder = async (newLinks: LinkData[]) => {
        // pinned primero
        const pinned = links.filter((l) => l.pinned).sort((a, b) => a.position - b.position);
        const combined = [...pinned, ...newLinks];
        setLinks(combined);

        const updates = newLinks.map((l) => ({ id: l.id, position: l.position }));
        try {
            await fetch("/api/links", {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(updates),
            });
        } catch (error) {
            console.error(error);
        }
    };

    // Separar pinned / normal
    const pinnedLinks = links
        .filter((l) => l.pinned)
        .sort((a, b) => a.position - b.position);

    const normalLinks = links
        .filter((l) => !l.pinned)
        .sort((a, b) => a.position - b.position);

    // =======================
    // RENDER
    // =======================
    return (
        <div className="p-4">
            <h1 className="text-2xl font-bold mb-4">Panel de Administración (Editables)</h1>

            {/* Formulario para crear enlaces */}
            <CreationForm
                newLink={newLink}
                setNewLink={setNewLink}
                onCreate={handleCreate}
                sections={sections} // <-- Para asignar section_id si deseas
            />

            {/* Lista de enlaces pinned */}
            {/*<PinnedList*/}
            {/*    pinnedLinks={pinnedLinks}*/}
            {/*    editingLinkId={editingLinkId}*/}
            {/*    editingTitle={editingTitle}*/}
            {/*    editingUrl={editingUrl}*/}
            {/*    setEditingTitle={setEditingTitle}*/}
            {/*    setEditingUrl={setEditingUrl}*/}
            {/*    onStartEditing={startEditing}*/}
            {/*    onSaveEditing={saveEditing}*/}
            {/*    onCancelEditing={cancelEditing}*/}
            {/*    onDelete={handleDelete}*/}
            {/*    onUpdateLink={handleUpdateLink}*/}
            {/*/>*/}

            {/* Lista de enlaces no pinned */}
            {/*<NonPinnedList*/}
            {/*    normalLinks={normalLinks}*/}
            {/*    editingLinkId={editingLinkId}*/}
            {/*    editingTitle={editingTitle}*/}
            {/*    editingUrl={editingUrl}*/}
            {/*    setEditingTitle={setEditingTitle}*/}
            {/*    setEditingUrl={setEditingUrl}*/}
            {/*    onStartEditing={startEditing}*/}
            {/*    onSaveEditing={saveEditing}*/}
            {/*    onCancelEditing={cancelEditing}*/}
            {/*    onDelete={handleDelete}*/}
            {/*    onUpdateLink={handleUpdateLink}*/}
            {/*    onReorder={handleReorder}*/}
            {/*/>*/}
            {/* Board para NO pinned, distribuidos en contenedores (no-section + secciones) */}
            <MultiSectionsBoard
                links={links}
                setLinks={setLinks}
                sections={sections}
            />

            {/* Panel para reordenar secciones (título, etc.) */}
            <SectionsPanel />

        </div>
    );
}



----- File: ./multi-sections-container.tsx -----
"use client";

import { useDroppable } from "@dnd-kit/core";
import { SortableContext, verticalListSortingStrategy } from "@dnd-kit/sortable";
import { LinkData, SectionData } from "./types";
import MultiSectionsItem from "./multi-sections-item";

interface MultiSectionsContainerProps {
    containerId: string; // "no-section" o section.id
    items: string[];     // array de link IDs
    links: LinkData[];
    sections: SectionData[];
}

export default function MultiSectionsContainer({
                                                   containerId,
                                                   items,
                                                   links,
                                                   sections,
                                               }: MultiSectionsContainerProps) {
    // useDroppable => este contenedor es droppable, aunque esté vacío
    const { setNodeRef } = useDroppable({ id: containerId });

    // Título
    let title = "Sin Sección";
    if (containerId !== "no-section") {
        const sec = sections.find((s) => s.id === containerId);
        if (sec) title = sec.title;
    }

    // Filtrar data real de los links
    const linkObjects = items.map((id) => links.find((l) => l.id === id)).filter(Boolean);

    return (
        <div ref={setNodeRef} className="border p-4 rounded bg-white/5">
            <h3 className="font-semibold text-lg mb-2">{title}</h3>
            <SortableContext items={items} strategy={verticalListSortingStrategy}>
                <ul className="space-y-2">
                    {linkObjects.map((link) => {
                        if (!link) return null;
                        return <MultiSectionsItem key={link.id} link={link} />;
                    })}
                </ul>
            </SortableContext>
            {items.length === 0 && (
                <p className="text-sm text-gray-400">Arrastra aquí enlaces para asignar</p>
            )}
        </div>
    );
}



